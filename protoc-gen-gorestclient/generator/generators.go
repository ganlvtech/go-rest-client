package generator

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"path"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"

	"github.com/ganlvtech/go-rest-client/protoc-gen-gorestclient/rest"
)

const (
	EmptyType string = ".google.protobuf.Empty"
)

type Printer interface {
	P(str ...interface{})
}

type Importer interface {
	AddImport(importPath string)
}

type FileGenerator struct {
	*bytes.Buffer

	FileDescriptorProto *descriptor.FileDescriptorProto

	EnumGenerators         []*EnumGenerator
	MessageGenerators      []*MessageGenerator
	ServiceGenerators      []*ServiceGenerator
	AllEnumGenerators      []*EnumGenerator
	AllMessageGenerators   []*MessageGenerator
	AllEnumGeneratorMap    map[string]*EnumGenerator
	AllMessageGeneratorMap map[string]*MessageGenerator
	AddedImports           map[string]bool
}

func NewFileGenerator(file *descriptor.FileDescriptorProto) *FileGenerator {
	g := new(FileGenerator)
	g.Buffer = new(bytes.Buffer)
	g.FileDescriptorProto = file
	g.AllEnumGeneratorMap = make(map[string]*EnumGenerator)
	g.AllMessageGeneratorMap = make(map[string]*MessageGenerator)
	g.AddedImports = make(map[string]bool)
	return g
}

func (g *FileGenerator) WrapTypes() {
	for _, v := range g.FileDescriptorProto.EnumType {
		enumGenerator := NewEnumGenerator(g, v, nil)
		g.EnumGenerators = append(g.EnumGenerators, enumGenerator)
		g.AllEnumGenerators = append(g.AllEnumGenerators, enumGenerator)
		g.AllEnumGeneratorMap[enumGenerator.FullyQualifiedName()] = enumGenerator
		enumGenerator.WrapTypes()
	}
	for _, v := range g.FileDescriptorProto.MessageType {
		messageGenerator := NewMessageGenerator(g, v, nil)
		g.MessageGenerators = append(g.MessageGenerators, messageGenerator)
		g.AllMessageGenerators = append(g.AllMessageGenerators, messageGenerator)
		g.AllMessageGeneratorMap[messageGenerator.FullyQualifiedName()] = messageGenerator
		messageGenerator.WrapTypes()
	}
	for _, v := range g.FileDescriptorProto.Service {
		serviceGenerator := NewServiceGenerator(g, v)
		g.ServiceGenerators = append(g.ServiceGenerators, serviceGenerator)
		serviceGenerator.WrapTypes()
	}
}

// printAtom prints the (atomic, non-annotation) argument to the generated output.
func (g *FileGenerator) printAtom(v interface{}) {
	switch v := v.(type) {
	case string:
		g.WriteString(v)
	case *string:
		g.WriteString(*v)
	case bool:
		fmt.Fprint(g, v)
	case *bool:
		fmt.Fprint(g, *v)
	case int:
		fmt.Fprint(g, v)
	case *int32:
		fmt.Fprint(g, *v)
	case *int64:
		fmt.Fprint(g, *v)
	case float64:
		fmt.Fprint(g, v)
	case *float64:
		fmt.Fprint(g, *v)
	// case GoPackageName:
	// 	g.WriteString(string(v))
	// case GoImportPath:
	// 	g.WriteString(strconv.Quote(string(v)))
	default:
		log.Fatal(fmt.Sprintf("unknown type in printer: %T", v))
	}
}

func (g *FileGenerator) P(str ...interface{}) {
	for _, v := range str {
		g.printAtom(v)
	}
	g.WriteByte('\n')
}

func (g *FileGenerator) AddImport(importPath string) {
	g.AddedImports[importPath] = true
}

func (g *FileGenerator) GoFileName() string {
	name := g.FileDescriptorProto.GetName()
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}
	name += ".pb.go"
	return name
}

func (g *FileGenerator) GoName() string {
	return ""
}

func (g *FileGenerator) FullQualifiedName() string {
	return "." + g.FileDescriptorProto.GetPackage()
}

func (g *FileGenerator) generatePackage() {
	g.P(`// Code generated by go-rest-client. DO NOT EDIT.`)
	g.P(`// source: `, g.FileDescriptorProto.GetName())
	g.P(`package `, g.FileDescriptorProto.GetPackage())
	g.P()
}

func (g *FileGenerator) generateEnumType() {
	for _, v := range g.EnumGenerators {
		v.Generate()
	}
}

func (g *FileGenerator) generateMessageType() {
	for _, v := range g.MessageGenerators {
		v.Generate()
	}
}

func (g *FileGenerator) generateService() {
	for _, v := range g.ServiceGenerators {
		v.Generate()
	}
}

func (g *FileGenerator) generateImport() {
	g.P(`import (`)
	for packageName, _ := range g.AddedImports {
		g.P(`"`, string(packageName), `"`)
	}
	g.P(`)`)
}

func (g *FileGenerator) Generate() {
	// g.loadOptions()
	g.generateEnumType()
	g.generateMessageType()
	g.generateService()
	rem := g.Buffer
	g.Buffer = new(bytes.Buffer)
	g.generatePackage()
	g.generateImport()
	g.Write(rem.Bytes())
	g.reformat()
}

// Reformat generated code
func (g *FileGenerator) reformat() {
	fset := token.NewFileSet()
	original := g.Bytes()
	fileAST, err := parser.ParseFile(fset, "", original, parser.ParseComments)
	if err != nil {
		// Print out the bad code with line numbers.
		// This should never happen in practice, but it can while changing generated code,
		// so consider this a debugging aid.
		var src bytes.Buffer
		s := bufio.NewScanner(bytes.NewReader(original))
		for line := 1; s.Scan(); line++ {
			fmt.Fprintf(&src, "%5d\t%s\n", line, s.Bytes())
		}
		log.Fatal("bad Go source code was generated:", err.Error(), "\n"+src.String())
	}
	ast.SortImports(fset, fileAST)
	g.Reset()
	err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(g, fset, fileAST)
	if err != nil {
		log.Fatal("generated Go source code could not be reformatted:", err.Error())
	}
}

type EnumGenerator struct {
	Printer
	// root element
	FileGenerator *FileGenerator
	// parent MessageGenerator, if no parent will be nil
	MessageGenerator    *MessageGenerator
	EnumDescriptorProto *descriptor.EnumDescriptorProto
	EnumValueGenerators []*EnumValueGenerator
}

func NewEnumGenerator(fileGenerator *FileGenerator, enumDescriptorProto *descriptor.EnumDescriptorProto, messageGenerator *MessageGenerator) *EnumGenerator {
	return &EnumGenerator{
		Printer:             fileGenerator,
		FileGenerator:       fileGenerator,
		MessageGenerator:    messageGenerator,
		EnumDescriptorProto: enumDescriptorProto,
	}
}

func (g *EnumGenerator) WrapTypes() {
	for i, v := range g.EnumDescriptorProto.Value {
		g.EnumValueGenerators = append(g.EnumValueGenerators, NewEnumValueGenerator(g, v, i))
	}
}

func (g *EnumGenerator) Name() string {
	return g.EnumDescriptorProto.GetName()
}

func (g *EnumGenerator) ParentGoName() string {
	if g.MessageGenerator != nil {
		return g.MessageGenerator.GoName()
	}
	return g.FileGenerator.GoName()
}

func (g *EnumGenerator) ParentFullQualifiedName() string {
	if g.MessageGenerator != nil {
		return g.MessageGenerator.FullyQualifiedName()
	}
	return g.FileGenerator.FullQualifiedName()
}

func (g *EnumGenerator) GoName() string {
	parentName := g.ParentGoName()
	if parentName != "" {
		return parentName + "_" + g.Name()
	}
	return g.Name()
}

func (g *EnumGenerator) FullyQualifiedName() string {
	return g.ParentFullQualifiedName() + "." + g.EnumDescriptorProto.GetName()
}

func (g *EnumGenerator) Generate() {
	g.P(`type `, g.GoName(), ` int32`)
	g.P(`const (`)
	for _, v := range g.EnumValueGenerators {
		v.generateConst()
	}
	g.P(`)`)
	g.P(`var `, g.GoName(), `_name = map[int32]string{`)
	for _, v := range g.EnumValueGenerators {
		v.generateName()
	}
	g.P(`}`)
	g.P(`var `, g.GoName(), `_value = map[string]int32{`)
	for _, v := range g.EnumValueGenerators {
		v.generateValue()
	}
	g.P(`}`)
	g.P()
}

type EnumValueGenerator struct {
	Printer
	EnumGenerator            *EnumGenerator
	EnumValueDescriptorProto *descriptor.EnumValueDescriptorProto
	Value                    int
}

func NewEnumValueGenerator(g *EnumGenerator, v *descriptor.EnumValueDescriptorProto, i int) *EnumValueGenerator {
	return &EnumValueGenerator{
		Printer:                  g,
		EnumGenerator:            g,
		EnumValueDescriptorProto: v,
		Value:                    i,
	}
}

func (g *EnumValueGenerator) Name() string {
	return g.EnumValueDescriptorProto.GetName()
}

func (g *EnumValueGenerator) GoName() string {
	return g.EnumGenerator.GoName() + "_" + g.Name()
}

func (g *EnumValueGenerator) generateConst() {
	g.P(g.GoName(), ` int32 = `, g.Value)
}

func (g *EnumValueGenerator) generateName() {
	g.P(g.Value, `: `, `"`, g.Name(), `",`)
}

func (g *EnumValueGenerator) generateValue() {
	g.P(`"`, g.Name(), `": `, g.Value, `,`)
}

type MessageGenerator struct {
	Printer
	// root element
	FileGenerator *FileGenerator
	// parent MessageGenerator, if no parent will be nil
	MessageGenerator  *MessageGenerator
	DescriptorProto   *descriptor.DescriptorProto
	FieldGenerators   []*FieldGenerator
	MessageGenerators []*MessageGenerator
	EnumGenerators    []*EnumGenerator
}

func NewMessageGenerator(fileGenerator *FileGenerator, descriptorProto *descriptor.DescriptorProto, messageGenerator *MessageGenerator) *MessageGenerator {
	return &MessageGenerator{
		Printer:          fileGenerator,
		FileGenerator:    fileGenerator,
		MessageGenerator: messageGenerator,
		DescriptorProto:  descriptorProto,
	}
}

func (g *MessageGenerator) WrapTypes() {
	for _, v := range g.DescriptorProto.Field {
		fieldGenerator := NewFieldGenerator(g, v)
		g.FieldGenerators = append(g.FieldGenerators, fieldGenerator)
	}
	for _, v := range g.DescriptorProto.NestedType {
		messageGenerator := NewMessageGenerator(g.FileGenerator, v, g)
		g.MessageGenerators = append(g.MessageGenerators, messageGenerator)
		g.FileGenerator.AllMessageGenerators = append(g.FileGenerator.AllMessageGenerators, messageGenerator)
		g.FileGenerator.AllMessageGeneratorMap[messageGenerator.FullyQualifiedName()] = messageGenerator
		messageGenerator.WrapTypes()
	}
	for _, v := range g.DescriptorProto.EnumType {
		enumGenerator := NewEnumGenerator(g.FileGenerator, v, g)
		g.EnumGenerators = append(g.EnumGenerators, enumGenerator)
		g.FileGenerator.AllEnumGenerators = append(g.FileGenerator.AllEnumGenerators, enumGenerator)
		g.FileGenerator.AllEnumGeneratorMap[enumGenerator.FullyQualifiedName()] = enumGenerator
		enumGenerator.WrapTypes()
	}
}

func (g *MessageGenerator) Name() string {
	return g.DescriptorProto.GetName()
}

func (g *MessageGenerator) ParentGoName() string {
	if g.MessageGenerator != nil {
		return g.MessageGenerator.GoName()
	}
	return g.FileGenerator.GoName()
}

func (g *MessageGenerator) ParentFullQualifiedName() string {
	if g.MessageGenerator != nil {
		return g.MessageGenerator.FullyQualifiedName()
	}
	return g.FileGenerator.FullQualifiedName()
}

func (g *MessageGenerator) GoName() string {
	parentName := g.ParentGoName()
	if parentName != "" {
		return parentName + "_" + g.Name()
	}
	return g.Name()
}

func (g *MessageGenerator) FullyQualifiedName() string {
	return g.ParentFullQualifiedName() + "." + g.DescriptorProto.GetName()
}

func (g *MessageGenerator) generateType() {
	g.P(`type `, g.GoName(), ` struct {`)
	for _, v := range g.FieldGenerators {
		v.Generate()
	}
	g.P(`}`)
}

func (g *MessageGenerator) generateNestedType() {
	for _, v := range g.MessageGenerators {
		v.Generate()
	}
}

func (g *MessageGenerator) Generate() {
	g.generateType()
	g.generateNestedType()
	g.P()
}

type FieldGenerator struct {
	Printer
	FieldDescriptorProto *descriptor.FieldDescriptorProto
	MessageGenerator     *MessageGenerator
}

func NewFieldGenerator(messageGenerator *MessageGenerator, fieldDescriptorProto *descriptor.FieldDescriptorProto) *FieldGenerator {
	return &FieldGenerator{
		Printer:              messageGenerator,
		MessageGenerator:     messageGenerator,
		FieldDescriptorProto: fieldDescriptorProto,
	}
}

// The original name in proto
func (g *FieldGenerator) Name() string {
	extensionName := g.ExtensionName()
	if extensionName != "" {
		return extensionName
	}
	return g.FieldDescriptorProto.GetName()
}

// Name used in go struct. Camel case to export this field in golang.
func (g *FieldGenerator) GoName() string {
	return CamelCase(g.Name())
}

func (g *FieldGenerator) GoType() string {
	return GoType(g.FieldDescriptorProto)
}

func (g *FieldGenerator) IsRepeat() bool {
	return g.FieldDescriptorProto.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED
}

func (g *FieldGenerator) ExtensionFieldMethod(value rest.HttpMethod) {
	if interface_, err := proto.GetExtension(g.FieldDescriptorProto.Options, rest.E_FieldMethod); err == nil {
		pointer := interface_.(*rest.HttpMethod)
		value = *pointer
	}
	return
}

func (g *FieldGenerator) ExtensionName() (value string) {
	if interface_, err := proto.GetExtension(g.FieldDescriptorProto.Options, rest.E_Name); err == nil {
		pointer := interface_.(*string)
		value = *pointer
	}
	return
}

func (g *FieldGenerator) ExtensionRequired() (value bool) {
	if interface_, err := proto.GetExtension(g.FieldDescriptorProto.Options, rest.E_Required); err == nil {
		pointer := interface_.(*bool)
		value = *pointer
	}
	return
}

func (g *FieldGenerator) ExtensionRequestParamNullable() (value bool) {
	if interface_, err := proto.GetExtension(g.FieldDescriptorProto.Options, rest.E_RequestParamNullable); err == nil {
		pointer := interface_.(*bool)
		value = *pointer
	}
	return
}

func (g *FieldGenerator) Generate() {
	typ := g.GoType()
	if g.ExtensionRequestParamNullable() {
		typ = "*" + typ
	}
	g.P(g.GoName(), ` `, typ, ` `, "`", `json:"`, g.Name(), `,omitempty"`, "`")
}

type ServiceGenerator struct {
	Printer
	Importer
	FileGenerator          *FileGenerator
	ServiceDescriptorProto *descriptor.ServiceDescriptorProto
	MethodGenerators       []*MethodGenerator
}

func NewServiceGenerator(fileGenerator *FileGenerator, serviceDescriptorProto *descriptor.ServiceDescriptorProto) *ServiceGenerator {
	return &ServiceGenerator{
		Printer:                fileGenerator,
		Importer:               fileGenerator,
		FileGenerator:          fileGenerator,
		ServiceDescriptorProto: serviceDescriptorProto,
	}
}

func (g *ServiceGenerator) WrapTypes() {
	for _, v := range g.ServiceDescriptorProto.Method {
		methodGenerator := NewMethodGenerator(g, v)
		g.MethodGenerators = append(g.MethodGenerators, methodGenerator)
	}
}

// The original name in proto
func (g *ServiceGenerator) Name() string {
	return g.ServiceDescriptorProto.GetName()
}

func (g *ServiceGenerator) generateClient() {
	g.P(`type `, g.Name(), `Service struct {`)
	g.P(`client *http.Client`)
	g.P(`baseUrl string`)
	g.P(`}`)
	g.P()
	g.AddImport("net/http")
	g.P(`func New`, g.Name(), `Service(client *http.Client, baseUrl string) *`, g.Name(), `Service {`)
	g.P(`return &`, g.Name(), `Service {`)
	g.P(`client: client,`)
	g.P(`baseUrl: baseUrl,`)
	g.P(`}`)
	g.P(`}`)
	g.P()
}

func (g *ServiceGenerator) generateMethods() {
	for _, v := range g.MethodGenerators {
		v.Generate()
	}
}

func (g *ServiceGenerator) Generate() {
	g.generateClient()
	g.generateMethods()
}

type MethodGenerator struct {
	Printer
	Importer
	ServiceGenerator      *ServiceGenerator
	MethodDescriptorProto *descriptor.MethodDescriptorProto
}

func NewMethodGenerator(serviceGenerator *ServiceGenerator, methodDescriptorProto *descriptor.MethodDescriptorProto) *MethodGenerator {
	return &MethodGenerator{
		Printer:               serviceGenerator,
		Importer:              serviceGenerator,
		ServiceGenerator:      serviceGenerator,
		MethodDescriptorProto: methodDescriptorProto,
	}
}

// The original name in proto
func (g *MethodGenerator) Name() string {
	return g.MethodDescriptorProto.GetName()
}

func (g *MethodGenerator) InputType() string {
	return g.MethodDescriptorProto.GetInputType()
}

func (g *MethodGenerator) OutputType() string {
	return g.MethodDescriptorProto.GetOutputType()
}

func (g *MethodGenerator) IsInputTypeEmpty() bool {
	return g.InputType() == EmptyType
}

func (g *MethodGenerator) IsOutputTypeEmpty() bool {
	return g.OutputType() == EmptyType
}

func (g *MethodGenerator) InputTypeMessageGenerator() *MessageGenerator {
	return g.ServiceGenerator.FileGenerator.AllMessageGeneratorMap[g.InputType()]
}

func (g *MethodGenerator) OutputTypeMessageGenerator() *MessageGenerator {
	return g.ServiceGenerator.FileGenerator.AllMessageGeneratorMap[g.OutputType()]
}

func (g *MethodGenerator) ExtensionPath() (value string) {
	if interface_, err := proto.GetExtension(g.MethodDescriptorProto.Options, rest.E_Path); err == nil {
		pointer := interface_.(*string)
		value = *pointer
	}
	return
}

func (g *MethodGenerator) ExtensionMethod() (value rest.HttpMethod) {
	if interface_, err := proto.GetExtension(g.MethodDescriptorProto.Options, rest.E_Method); err == nil {
		pointer := interface_.(*rest.HttpMethod)
		value = *pointer
	}
	return
}

func (g *MethodGenerator) ExtensionUrl() (value string) {
	if interface_, err := proto.GetExtension(g.MethodDescriptorProto.Options, rest.E_Url); err == nil {
		pointer := interface_.(*string)
		value = *pointer
	}
	return
}

func (g *MethodGenerator) ExtensionNoCookie() (value bool) {
	if interface_, err := proto.GetExtension(g.MethodDescriptorProto.Options, rest.E_NoCookie); err == nil {
		pointer := interface_.(*bool)
		value = *pointer
	}
	return
}

func (g *MethodGenerator) ExtensionRequestContentType() (value rest.RequestContentType) {
	if interface_, err := proto.GetExtension(g.MethodDescriptorProto.Options, rest.E_RequestContentType); err == nil {
		pointer := interface_.(*rest.RequestContentType)
		value = *pointer
	}
	return
}

func (g *MethodGenerator) Generate() {
	isInputTypeEmpty := g.IsInputTypeEmpty()
	isOutputTypeEmpty := g.IsOutputTypeEmpty()
	var inputParamList string
	var outputParamList string
	if !isInputTypeEmpty {
		inputParamList = "in *" + g.InputTypeMessageGenerator().GoName()
	}
	if !isOutputTypeEmpty {
		outputParamList = "(out *" + g.OutputTypeMessageGenerator().GoName() + ", resp *http.Response, err error)"
	} else {
		outputParamList = "(resp *http.Response, err error)"
	}
	g.P("func (s *", g.ServiceGenerator.Name(), "Service) ", g.Name(), "(", inputParamList, ") ", outputParamList, " {")

	requestContentType := g.ExtensionRequestContentType()
	if !isInputTypeEmpty {
		switch requestContentType {
		case rest.RequestContentType_APPLICATION_X_WWW_FORM_URLENCODED:
			g.generateApplicationXWwwFormUrlencoded()
		case rest.RequestContentType_MULTIPART_FORM_DATA:
			g.generateMultipartFormData()
		}
	}

	httpMethod := g.ExtensionMethod()
	// TODO querystring in POST request
	switch httpMethod {
	case rest.HttpMethod_GET:
		if !isInputTypeEmpty {
			g.P(`req, err := http.NewRequest("GET", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `?" + v.Encode()`, `, nil)`)
		} else {
			g.P(`req, err := http.NewRequest("GET", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `"`, `, nil)`)
		}
	case rest.HttpMethod_POST:
		if !isInputTypeEmpty {
			switch requestContentType {
			case rest.RequestContentType_APPLICATION_X_WWW_FORM_URLENCODED:
				g.AddImport("strings")
				g.P(`req, err := http.NewRequest("POST", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `", strings.NewReader(v.Encode()))`)
			case rest.RequestContentType_MULTIPART_FORM_DATA:
				g.P(`req, err := http.NewRequest("POST", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `", &b)`)
			}
		} else {
			g.P(`req, err := http.NewRequest("POST", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `"`, `, nil)`)
		}
	}

	g.P(`if err != nil {`)
	g.P(`return`)
	g.P(`}`)
	if httpMethod == rest.HttpMethod_POST {
		switch requestContentType {
		case rest.RequestContentType_APPLICATION_X_WWW_FORM_URLENCODED:
			g.P(`req.Header.Set("Content-Type", "application/x-www-form-urlencoded")`)
		case rest.RequestContentType_MULTIPART_FORM_DATA:
			g.P(`req.Header.Set("Content-Type", w.FormDataContentType())`)
		}
	}
	g.P(`resp, err = s.client.Do(req)`)
	g.P(`if err != nil {`)
	g.P(`return`)
	g.P(`}`)
	g.P(`defer resp.Body.Close()`)
	if !isOutputTypeEmpty {
		g.P(`out = &`, g.OutputTypeMessageGenerator().GoName(), `{}`)
		g.AddImport("encoding/json")
		g.P(`err = json.NewDecoder(resp.Body).Decode(out)`)
		g.P(`if err != nil {`)
		g.P(`return`)
		g.P(`}`)
	}
	g.P(`return`)
	g.P(`}`)
	g.P()
}

func (g *MethodGenerator) generateApplicationXWwwFormUrlencoded() {
	g.AddImport("net/url")
	g.P(`v := url.Values{}`)
	for _, v := range g.InputTypeMessageGenerator().FieldGenerators {
		varName := "in." + v.GoName()
		if v.ExtensionRequestParamNullable() {
			g.P(`if `, varName, ` != nil {`)
			varName = "*" + varName
		}
		if v.IsRepeat() {
			g.P(`for _, v1 := range `, varName, ` {`)
			varName = "v1"
		}
		switch v.FieldDescriptorProto.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
			g.AddImport("strconv")
			g.P(`v.Add("`, v.Name(), `", strconv.FormatFloat(float64(`, varName, `), 'g', -1, 64))`)
		case descriptor.FieldDescriptorProto_TYPE_FLOAT:
			g.AddImport("strconv")
			g.P(`v.Add("`, v.Name(), `", strconv.FormatFloat(float64(`, varName, `), 'g', -1, 32))`)
		case descriptor.FieldDescriptorProto_TYPE_UINT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_UINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED32:
			g.AddImport("strconv")
			g.P(`v.Add("`, v.Name(), `", strconv.FormatUint(uint64(`, varName, `), 10))`)
		case descriptor.FieldDescriptorProto_TYPE_INT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_INT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT64:
			g.AddImport("strconv")
			g.P(`v.Add("`, v.Name(), `", strconv.FormatInt(int64(`, varName, `), 10))`)
		case descriptor.FieldDescriptorProto_TYPE_BOOL:
			g.AddImport("strconv")
			g.P(`v.Add("`, v.Name(), `", strconv.FormatBool(`, varName, `))`)
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_GROUP:
			g.P(`v.Add("`, v.Name(), `", `, varName, `)`)
		default:
			g.P(`v.Add("`, v.Name(), `", `, varName, `)`)
		}
		if v.IsRepeat() {
			g.P(`}`)
		}
		if v.ExtensionRequestParamNullable() {
			g.P(`}`)
		}
	}
}

func (g *MethodGenerator) generateMultipartFormData() {
	g.AddImport("bytes")
	g.P(`var b bytes.Buffer`)
	g.AddImport("mime/multipart")
	g.P(`w := multipart.NewWriter(&b)`)
	for _, v := range g.InputTypeMessageGenerator().FieldGenerators {
		if v.FieldDescriptorProto.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			switch v.FieldDescriptorProto.GetTypeName() {
			case ".rest.RequestFile":
				g.P(`file := in.`, v.GoName())
				g.P(`writer`, v.Name(), `, err := w.CreateFormFile("`, v.Name(), `", file.Name())`)
				g.P(`if err != nil {`)
				g.P(`return nil, nil, err`)
				g.P(`}`)
				g.AddImport("io")
				g.P(`_, err = io.Copy(writer`, v.Name(), `, file)`)
				g.P(`if err != nil {`)
				g.P(`return nil, nil, err`)
				g.P(`}`)
			}
		} else {
			varName := "in." + v.GoName()
			fieldName := v.Name()
			if v.ExtensionRequestParamNullable() {
				g.P(`if `, varName, ` != nil {`)
				varName = "*" + varName
			}
			if v.IsRepeat() {
				g.P(`for _, v1 := range `, varName, ` {`)
				varName = "v1"
				fieldName += "[]"
			}
			writerName := `writer` + v.GoName()
			if v.FieldDescriptorProto.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
				switch v.FieldDescriptorProto.GetTypeName() {
				case ".rest.RequestFile":
					g.P(`file := `, varName)
					g.P(writerName, `, err := w.CreateFormFile("`, fieldName, `", file.Name())`)
					g.P(`if err != nil {`)
					g.P(`return nil, nil, err`)
					g.P(`}`)
					g.AddImport("io")
					g.P(`_, err = io.Copy(writer`, v.Name(), `, file)`)
					g.P(`if err != nil {`)
					g.P(`return nil, nil, err`)
					g.P(`}`)
				}
			} else {
				g.P(writerName, `, err := w.CreateFormField("`, fieldName, `")`)
				g.P(`if err != nil {`)
				g.P(`return nil, nil, err`)
				g.P(`}`)
				switch v.FieldDescriptorProto.GetType() {
				case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
					g.AddImport("strconv")
					g.P(writerName, `.Write([]byte(strconv.FormatFloat(float64(`, varName, `), 'g', -1, 64)))`)
				case descriptor.FieldDescriptorProto_TYPE_FLOAT:
					g.AddImport("strconv")
					g.P(writerName, `.Write([]byte(strconv.FormatFloat(float64(`, varName, `), 'g', -1, 32)))`)
				case descriptor.FieldDescriptorProto_TYPE_UINT64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_UINT32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_FIXED64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_FIXED32:
					g.AddImport("strconv")
					g.P(writerName, `.Write([]byte(strconv.FormatUint(uint64(`, varName, `), 10)))`)
				case descriptor.FieldDescriptorProto_TYPE_INT64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_INT32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SINT32:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_SINT64:
					g.AddImport("strconv")
					g.P(writerName, `.Write([]byte(strconv.FormatInt(int64(`, varName, `), 10)))`)
				case descriptor.FieldDescriptorProto_TYPE_BOOL:
					g.AddImport("strconv")
					g.P(writerName, `.Write([]byte(strconv.FormatBool(`, varName, `)))`)
				case descriptor.FieldDescriptorProto_TYPE_STRING:
					fallthrough
				case descriptor.FieldDescriptorProto_TYPE_GROUP:
					g.P(writerName, `.Write([]byte(`, varName, `))`)
				default:
					g.P(writerName, `.Write([]byte(`, varName, `))`)
				}
			}
			if v.IsRepeat() {
				g.P(`}`)
			}
			if v.ExtensionRequestParamNullable() {
				g.P(`}`)
			}
		}
	}
	g.P(`w.Close()`)
}
