package generator

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"path"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"

	"github.com/ganlvtech/go-rest-client/protoc-gen-gorestclient/rest"
)

const (
	EmptyType string = ".google.protobuf.Empty"
)

type GoImportPath string
type GoPackageName string

type Printer interface {
	P(str ...interface{})
}

type Importer interface {
	AddImport(importPath GoImportPath)
}

type FileGenerator struct {
	*bytes.Buffer

	FileDescriptorProto *descriptor.FileDescriptorProto

	usedPackages map[GoImportPath]bool
	packageNames map[GoImportPath]GoPackageName
	addedImports map[GoImportPath]bool
	messageMap   map[string]*descriptor.DescriptorProto
}

func NewFileGenerator(file *descriptor.FileDescriptorProto) *FileGenerator {
	g := new(FileGenerator)
	g.Buffer = new(bytes.Buffer)
	g.FileDescriptorProto = file
	g.usedPackages = make(map[GoImportPath]bool)
	g.packageNames = make(map[GoImportPath]GoPackageName)
	g.addedImports = make(map[GoImportPath]bool)
	g.messageMap = make(map[string]*descriptor.DescriptorProto)
	return g
}

// printAtom prints the (atomic, non-annotation) argument to the generated output.
func (g *FileGenerator) printAtom(v interface{}) {
	switch v := v.(type) {
	case string:
		g.WriteString(v)
	case *string:
		g.WriteString(*v)
	case bool:
		fmt.Fprint(g, v)
	case *bool:
		fmt.Fprint(g, *v)
	case int:
		fmt.Fprint(g, v)
	case *int32:
		fmt.Fprint(g, *v)
	case *int64:
		fmt.Fprint(g, *v)
	case float64:
		fmt.Fprint(g, v)
	case *float64:
		fmt.Fprint(g, *v)
	// case GoPackageName:
	// 	g.WriteString(string(v))
	// case GoImportPath:
	// 	g.WriteString(strconv.Quote(string(v)))
	default:
		log.Fatal(fmt.Sprintf("unknown type in printer: %T", v))
	}
}

func (g *FileGenerator) P(str ...interface{}) {
	for _, v := range str {
		g.printAtom(v)
	}
	g.WriteByte('\n')
}

func (g *FileGenerator) GoFileName() string {
	name := g.FileDescriptorProto.GetName()
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}
	name += ".pb.go"
	return name
}

func (g *FileGenerator) AddImport(importPath GoImportPath) {
	g.addedImports[importPath] = true
}

func (g *FileGenerator) Generate() {
	// g.loadOptions()
	g.generateEnumType()
	g.generateMessageType()
	g.generateService()
	rem := g.Buffer
	g.Buffer = new(bytes.Buffer)
	g.generatePackage()
	g.generateImport()
	g.Write(rem.Bytes())
	g.reformat()
}

func (g *FileGenerator) generatePackage() {
	g.P(`// Code generated by go-rest-client. DO NOT EDIT.`)
	g.P(`// source: `, g.FileDescriptorProto.GetName())
	g.P(`package `, g.FileDescriptorProto.GetPackage())
	g.P()
}

func (g *FileGenerator) generateEnumType() {
	for _, v := range g.FileDescriptorProto.EnumType {
		generator := &EnumGenerator{
			Printer:             g,
			EnumDescriptorProto: v,
		}
		generator.Generate()
	}
}

func (g *FileGenerator) generateMessageType() {
	for _, v := range g.FileDescriptorProto.MessageType {
		generator := &MessageGenerator{
			Printer:         g,
			FileGenerator:   g,
			DescriptorProto: v,
		}
		generator.Generate()
	}
}

func (g *FileGenerator) generateService() {
	for _, v := range g.FileDescriptorProto.Service {
		generator := &ServiceGenerator{
			Printer:                g,
			Importer:               g,
			FileGenerator:          g,
			ServiceDescriptorProto: v,
		}
		generator.Generate()
	}
}

func (g *FileGenerator) generateImport() {
	g.P(`import (`)
	for packageName, _ := range g.addedImports {
		g.P(`"`, string(packageName), `"`)
	}
	g.P(`)`)
}

// Reformat generated code
func (g *FileGenerator) reformat() {
	fset := token.NewFileSet()
	original := g.Bytes()
	fileAST, err := parser.ParseFile(fset, "", original, parser.ParseComments)
	if err != nil {
		// Print out the bad code with line numbers.
		// This should never happen in practice, but it can while changing generated code,
		// so consider this a debugging aid.
		var src bytes.Buffer
		s := bufio.NewScanner(bytes.NewReader(original))
		for line := 1; s.Scan(); line++ {
			fmt.Fprintf(&src, "%5d\t%s\n", line, s.Bytes())
		}
		log.Fatal("bad Go source code was generated:", err.Error(), "\n"+src.String())
	}
	ast.SortImports(fset, fileAST)
	g.Reset()
	err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(g, fset, fileAST)
	if err != nil {
		log.Fatal("generated Go source code could not be reformatted:", err.Error())
	}
}

type EnumGenerator struct {
	Printer
	Prefix              string
	EnumDescriptorProto *descriptor.EnumDescriptorProto
}

func (g *EnumGenerator) Name() string {
	if g.Prefix != "" {
		return g.Prefix + "_" + g.EnumDescriptorProto.GetName()
	}
	return g.EnumDescriptorProto.GetName()
}

func (g *EnumGenerator) Generate() {
	g.P(`type `, g.Name(), ` int32`)
	g.P(`const (`)
	for i, enumValue := range g.EnumDescriptorProto.Value {
		g.P(g.Name(), `_`, enumValue.GetName(), ` int32 = `, i)
	}
	g.P(`)`)
	g.P(`var Conversation_Discriminator_name = map[int32]string{`)
	for i, enumValue := range g.EnumDescriptorProto.Value {
		g.P(i, `: `, `"`, enumValue.GetName(), `",`)
	}
	g.P(`}`)
	g.P(`var Conversation_Discriminator_value = map[string]int32{`)
	for i, enumValue := range g.EnumDescriptorProto.Value {
		g.P(`"`, enumValue.GetName(), `": `, i, `,`)
	}
	g.P(`}`)
	g.P()
}

type MessageGenerator struct {
	Printer
	Prefix          string
	FileGenerator   *FileGenerator
	DescriptorProto *descriptor.DescriptorProto
}

func (g *MessageGenerator) Name() string {
	if g.Prefix != "" {
		return g.Prefix + "_" + g.DescriptorProto.GetName()
	}
	return g.DescriptorProto.GetName()
}

func (g *MessageGenerator) generate() {
	g.P(`type `, g.Name(), ` struct {`)
	for _, field := range g.DescriptorProto.Field {
		fieldGenerator := &FieldGenerator{
			Printer:              g,
			FieldDescriptorProto: field,
		}
		fieldGenerator.Generate()
	}
	g.P(`}`)
	g.FileGenerator.messageMap[g.Name()] = g.DescriptorProto
}

func (g *MessageGenerator) generateNestedType() {
	for _, v := range g.DescriptorProto.NestedType {
		generator := &MessageGenerator{
			Printer:         g,
			Prefix:          g.Name(),
			FileGenerator:   g.FileGenerator,
			DescriptorProto: v,
		}
		generator.Generate()
	}
}

func (g *MessageGenerator) Generate() {
	g.generate()
	g.generateNestedType()
	g.P()
}

type FieldGenerator struct {
	Printer
	FieldDescriptorProto *descriptor.FieldDescriptorProto
}

// The original name in proto
func (g *FieldGenerator) Name() string {
	return g.FieldDescriptorProto.GetName()
}

// Name used in go struct. Camel case to export this field in golang.
func (g *FieldGenerator) CamelCaseName() string {
	return CamelCase(g.Name())
}

func (g *FieldGenerator) Type() string {
	return GoType(g.FieldDescriptorProto)
}

func (g *FieldGenerator) IsRepeat() bool {
	return g.FieldDescriptorProto.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED
}

func (g *FieldGenerator) Generate() {
	g.P(g.CamelCaseName(), ` `, g.Type(), ` `, "`", `json:"`, g.Name(), `,omitempty"`, "`")
}

type ServiceGenerator struct {
	Printer
	Importer
	FileGenerator *FileGenerator
	*descriptor.ServiceDescriptorProto
}

// The original name in proto
func (g *ServiceGenerator) Name() string {
	return g.ServiceDescriptorProto.GetName()
}

func (g *ServiceGenerator) generateClient() {
	g.P(`type `, g.Name(), `Service struct {`)
	g.P(`client *http.Client`)
	g.P(`baseUrl string`)
	g.P(`}`)
	g.P()
	g.AddImport("net/http")
	g.P(`func New`, g.Name(), `Service(client *http.Client, baseUrl string) *`, g.Name(), `Service {`)
	g.P(`return &`, g.Name(), `Service {`)
	g.P(`client: client,`)
	g.P(`baseUrl: baseUrl,`)
	g.P(`}`)
	g.P(`}`)
	g.P()
}

func (g *ServiceGenerator) Generate() {
	g.generateClient()
	for _, method := range g.ServiceDescriptorProto.Method {
		generator := &MethodGenerator{
			Printer:               g,
			Importer:              g,
			ServiceGenerator:      g,
			MethodDescriptorProto: method,
		}
		generator.Generate()
	}
}

type MethodGenerator struct {
	Printer
	Importer
	*ServiceGenerator
	*descriptor.MethodDescriptorProto
}

// The original name in proto
func (g *MethodGenerator) Name() string {
	return g.MethodDescriptorProto.GetName()
}

func (g *MethodGenerator) Generate() {
	inputType := g.MethodDescriptorProto.GetInputType()
	outputType := g.MethodDescriptorProto.GetOutputType()
	isInputEmpty := inputType == EmptyType
	isOutputEmpty := outputType == EmptyType
	var inputParamList string
	var outputParamList string
	var inputGoType string
	var outputGoType string
	if !isInputEmpty {
		inputGoType = FullQualifiedTypeNameToGoType(inputType)
		inputParamList = "in *" + inputGoType
	}
	if !isOutputEmpty {
		outputGoType = FullQualifiedTypeNameToGoType(outputType)
		outputParamList = "(out *" + outputGoType + ", resp *http.Response, err error)"
	} else {
		outputParamList = "(resp *http.Response, err error)"
	}
	g.P("func (s *", g.ServiceGenerator.Name(), "Service) ", g.Name(), "(", inputParamList, ") ", outputParamList, " {")
	requestContentType := rest.RequestContentType_APPLICATION_X_WWW_FORM_URLENCODED
	requestContentTypeProto, err := proto.GetExtension(g.MethodDescriptorProto.Options, rest.E_RequestContentType)
	if err == nil {
		requestContentType = *requestContentTypeProto.(*rest.RequestContentType)
	}
	if !isInputEmpty {
		switch requestContentType {
		case rest.RequestContentType_APPLICATION_X_WWW_FORM_URLENCODED:
			g.generateApplicationXWwwFormUrlencoded(inputGoType)
		case rest.RequestContentType_MULTIPART_FORM_DATA:
			g.generateMultipartFormData(inputGoType)
		}
	}

	httpMethodInterface, err := proto.GetExtension(g.MethodDescriptorProto.Options, rest.E_Method)
	httpMethod := rest.HttpMethod_GET
	if err == nil {
		httpMethod = *(httpMethodInterface.(*rest.HttpMethod))
	}

	// TODO querystring in POST request
	switch httpMethod {
	case rest.HttpMethod_GET:
		if !isInputEmpty {
			g.P(`req, err := http.NewRequest("GET", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `?" + v.Encode()`, `, nil)`)
		} else {
			g.P(`req, err := http.NewRequest("GET", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `"`, `, nil)`)
		}
	case rest.HttpMethod_POST:
		if !isInputEmpty {
			switch requestContentType {
			case rest.RequestContentType_APPLICATION_X_WWW_FORM_URLENCODED:
				g.AddImport("strings")
				g.P(`req, err := http.NewRequest("POST", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `", strings.NewReader(v.Encode()))`)
			case rest.RequestContentType_MULTIPART_FORM_DATA:
				g.P(`req, err := http.NewRequest("POST", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `", &b)`)
			}
		} else {
			g.P(`req, err := http.NewRequest("POST", s.baseUrl+"/`, g.ServiceGenerator.Name(), `/`, g.Name(), `"`, `, nil)`)
		}
	}

	g.P(`if err != nil {`)
	g.P(`return`)
	g.P(`}`)
	if httpMethod == rest.HttpMethod_POST {
		switch requestContentType {
		case rest.RequestContentType_APPLICATION_X_WWW_FORM_URLENCODED:
			g.P(`req.Header.Set("Content-Type", "application/x-www-form-urlencoded")`)
		case rest.RequestContentType_MULTIPART_FORM_DATA:
			g.P(`req.Header.Set("Content-Type", w.FormDataContentType())`)
		}
	}
	g.P(`resp, err = s.client.Do(req)`)
	g.P(`if err != nil {`)
	g.P(`return`)
	g.P(`}`)
	g.P(`defer resp.Body.Close()`)
	if !isOutputEmpty {
		g.P(`out = &`, outputGoType, `{}`)
		g.AddImport("encoding/json")
		g.P(`err = json.NewDecoder(resp.Body).Decode(out)`)
		g.P(`if err != nil {`)
		g.P(`return`)
		g.P(`}`)
	}
	g.P(`return`)
	g.P(`}`)
	g.P()
}

func (g *MethodGenerator) generateApplicationXWwwFormUrlencoded(inputGoType string) {
	g.AddImport("net/url")
	g.P(`v := url.Values{}`)
	for _, v := range g.ServiceGenerator.FileGenerator.messageMap[inputGoType].Field {
		generator := &FieldGenerator{
			Printer:              g,
			FieldDescriptorProto: v,
		}
		var varName string
		if generator.IsRepeat() {
			g.P(`for _, v1 := range in.`, generator.CamelCaseName(), ` {`)
			varName = "v1"
		} else {
			varName = "in." + generator.CamelCaseName()
		}
		switch v.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
			g.AddImport("strconv")
			g.P(`v.Add("`, generator.Name(), `", strconv.FormatFloat(float64(`, varName, `), 'g', -1, 64))`)
		case descriptor.FieldDescriptorProto_TYPE_FLOAT:
			g.AddImport("strconv")
			g.P(`v.Add("`, generator.Name(), `", strconv.FormatFloat(float64(`, varName, `), 'g', -1, 32))`)
		case descriptor.FieldDescriptorProto_TYPE_UINT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_UINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_FIXED32:
			g.AddImport("strconv")
			g.P(`v.Add("`, generator.Name(), `", strconv.FormatUint(uint64(`, varName, `), 10))`)
		case descriptor.FieldDescriptorProto_TYPE_INT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_INT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT32:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SINT64:
			g.AddImport("strconv")
			g.P(`v.Add("`, generator.Name(), `", strconv.FormatInt(int64(`, varName, `), 10))`)
		case descriptor.FieldDescriptorProto_TYPE_BOOL:
			g.AddImport("strconv")
			g.P(`v.Add("`, generator.Name(), `", strconv.FormatBool(`, varName, `))`)
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_GROUP:
			g.P(`v.Add("`, generator.Name(), `", `, varName, `)`)
		default:
			g.P(`v.Add("`, generator.Name(), `", `, varName, `)`)
		}
		if generator.IsRepeat() {
			g.P(`}`)
		}
	}
}

func (g *MethodGenerator) generateMultipartFormData(inputGoType string) {
	g.AddImport("bytes")
	g.P(`var b bytes.Buffer`)
	g.AddImport("mime/multipart")
	g.P(`w := multipart.NewWriter(&b)`)
	for _, v := range g.ServiceGenerator.FileGenerator.messageMap[inputGoType].Field {
		if v.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			switch v.GetTypeName() {
			case ".rest.RequestFile":
				generator := &FieldGenerator{
					Printer:              g,
					FieldDescriptorProto: v,
				}
				g.P(`file := *in.`, generator.CamelCaseName())
				g.P(`writer`, generator.Name(), `, err := w.CreateFormFile("`, generator.Name(), `", file.Name())`)
				g.P(`if err != nil {`)
				g.P(`return nil, nil, err`)
				g.P(`}`)
				g.AddImport("io")
				g.P(`_, err = io.Copy(writer`, generator.Name(), `, file)`)
				g.P(`if err != nil {`)
				g.P(`return nil, nil, err`)
				g.P(`}`)
			}
		} else {
			generator := &FieldGenerator{
				Printer:              g,
				FieldDescriptorProto: v,
			}
			varName := `in.` + generator.CamelCaseName()
			g.P(`writer`, generator.Name(), `, err := w.CreateFormField("`, generator.Name(), `")`)
			g.P(`if err != nil {`)
			g.P(`return nil, nil, err`)
			g.P(`}`)
			// TODO repeated
			switch *v.Type {
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
				g.AddImport("strconv")
				g.P(`writer`, v.Name, `.Write([]byte(strconv.FormatFloat(float64(`, varName, `), 'g', -1, 64)))`)
			case descriptor.FieldDescriptorProto_TYPE_FLOAT:
				g.AddImport("strconv")
				g.P(`writer`, v.Name, `.Write([]byte(strconv.FormatFloat(float64(`, varName, `), 'g', -1, 32)))`)
			case descriptor.FieldDescriptorProto_TYPE_UINT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_UINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_FIXED32:
				g.AddImport("strconv")
				g.P(`writer`, v.Name, `.Write([]byte(strconv.FormatUint(uint64(`, varName, `), 10)))`)
			case descriptor.FieldDescriptorProto_TYPE_INT64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_INT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT32:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_SINT64:
				g.AddImport("strconv")
				g.P(`writer`, v.Name, `.Write([]byte(strconv.FormatInt(int64(`, varName, `), 10)))`)
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				g.AddImport("strconv")
				g.P(`writer`, v.Name, `.Write([]byte(strconv.FormatBool(`, varName, `)))`)
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				fallthrough
			case descriptor.FieldDescriptorProto_TYPE_GROUP:
				g.P(`writer`, v.Name, `.Write([]byte(`, varName, `))`)
			default:
				g.P(`writer`, v.Name, `.Write([]byte(`, varName, `))`)
			}
		}
	}
	g.P(`w.Close()`)
}
